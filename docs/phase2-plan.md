# Phase 2 実装計画

## 概要

Phase 1で87.5%のテスト成功率を達成した基盤の上に、実用的なScalaコードのフォーマッティングに必要な高度な機能を実装します。

## 実装順序と優先度

### 1. ジェネリクス (Type Parameters) - 高優先度
**理由**: 実世界のScalaコードで最も頻繁に使用される機能の一つ

- 型パラメータ定義: `class Box[T]`
- 型パラメータ使用: `List[Int]`, `Map[String, User]`
- 型境界: `[T <: AnyRef]`, `[T >: Nothing]`
- 複数型パラメータ: `[K, V]`

### 2. ケースクラス - 高優先度
**理由**: Scalaの最重要機能の一つで、データモデリングに必須

- 基本的なケースクラス: `case class Person(name: String, age: Int)`
- ネストしたケースクラス
- コンパニオンオブジェクト対応

### 3. コンストラクタ呼び出し (new) - 中優先度
**理由**: オブジェクト生成の基本機能

- 基本的なインスタンス生成: `new Person("Alice", 30)`
- 型パラメータ付き: `new List[Int]()`
- 無名クラス: `new Trait { ... }`

### 4. パターンマッチング - 高優先度
**理由**: Scalaの関数型プログラミングの中核

- 基本的なmatch式: `x match { case ... => ... }`
- ケースクラスのパターンマッチ
- ガード条件: `case x if x > 0 =>`
- ワイルドカード: `case _ =>`

### 5. 関数型機能 - 中優先度
**理由**: Scalaの表現力を支える重要機能

- メソッドチェーン: `.map().filter().collect()`
- for内包表記: `for (x <- xs; y <- ys) yield x + y`
- 高階関数の適切なフォーマット

## 実装アプローチ

### レキサー拡張
1. 新しいトークンの追加（必要に応じて）
2. 既存トークンの調整

### パーサー拡張
1. 新しい構文ルールの追加
2. 既存ルールの拡張
3. CST構造の最適化

### プリンター拡張
1. 新しいノードタイプのハンドリング
2. フォーマッティングルールの実装
3. インデントとスペーシングの調整

## テスト戦略

各機能について：
1. 単体テスト（最小構文のテスト）
2. 統合テスト（複合的な構文のテスト）
3. エッジケーステスト
4. scalafmtとの互換性確認

## 成功基準

- Phase 2完了時のテスト成功率: 95%以上
- 実世界のScalaプロジェクトでの動作確認
- パフォーマンスの維持（Phase 1と同等以上）

## リスクと対策

1. **パーサーの複雑化**
   - 対策: モジュール化と責任の分離

2. **パフォーマンス低下**
   - 対策: プロファイリングと最適化

3. **後方互換性**
   - 対策: 既存テストの維持と回帰テスト